
1. 会话安全性
会话劫持和防御

会话劫持指攻击者窃取用户的会话 ID 来冒充该用户与服务器进行交互，通常通过网络监听、跨站脚本 (XSS) 或其他手段获取会话 ID。
防御措施：
使用 HTTPS 加密通信，防止会话 ID 被窃取。
设置 Cookie 的 HttpOnly 和 Secure 标志，防止 JavaScript 访问会话 ID，且只能在安全连接（HTTPS）上传输。
重新生成会话 ID 在用户登录或权限变化时，防止攻击者利用先前的会话 ID。
跨站脚本攻击（XSS）和防御

XSS 是一种攻击方式，攻击者通过注入恶意脚本在用户的浏览器中执行，窃取敏感信息或控制用户操作。
防御措施：
输入验证和输出编码：确保用户输入不会被当作脚本执行，通过 HTML 编码来避免脚本注入。
Content Security Policy (CSP)：限制页面中允许执行的脚本来源，减少恶意脚本执行的可能性。
跨站请求伪造（CSRF）和防御

CSRF 是一种攻击方式，攻击者利用已登录用户的身份发起恶意请求，通常会在用户不知情的情况下进行。
防御措施：
CSRF 令牌：每次请求携带一个唯一的令牌，服务器验证令牌的有效性，确保请求是由合法用户发起。
Referer 头验证：检查请求的来源是否与预期相符。
2. 分布式会话管理
分布式环境下的会话同步问题

在分布式系统中，用户的请求可能被不同的服务器处理。会话信息如果保存在单个服务器上，当用户的请求被路由到其他服务器时，无法访问先前的会话数据。因此，会话同步问题需要在多个服务器之间共享或同步会话状态。
Session 集群解决方案

Session 复制：会话数据复制到集群中每个节点，所有节点共享会话信息。适合小规模集群，但可能导致同步延迟和性能问题。
Sticky Session（会话粘滞）：通过负载均衡器将同一用户的请求始终路由到同一台服务器。这样减少了会话同步，但如果该服务器失效，可能会导致会话丢失。
外部 Session 存储：会话数据存储在外部系统（如 Redis、数据库等）中，所有服务器共享外部会话数据，从而实现会话同步。
使用 Redis 等缓存技术实现分布式会话

Redis 是一种常用的分布式缓存工具，可以高效地存储和同步会话数据。在分布式环境中，使用 Redis 存储会话状态，确保不同服务器都能访问同一个会话信息。
3. 会话状态的序列化和反序列化
会话状态的序列化和反序列化

在分布式环境或外部存储中，服务器需要将会话对象转换为字节流（序列化）存储在 Redis 或数据库中。然后，在请求到来时，将存储的字节流转换回对象（反序列化）使用。
为什么需要序列化会话状态

序列化允许会话数据在不同服务器之间传输或保存。对于分布式会话管理，将会话状态序列化后存储在外部系统中，确保所有服务器能访问共享的会话数据。
Java 对象序列化

Java 的序列化机制是通过 Serializable 接口实现的，它将 Java 对象转换为字节流进行存储或传输。
自定义序列化策略

在某些情况下，默认的序列化机制可能会导致性能问题或安全隐患。通过实现 Externalizable 接口，可以手动控制对象的序列化过程，灵活决定哪些字段需要序列化，从而优化性能或避免敏感数据的泄露。